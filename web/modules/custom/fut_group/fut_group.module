<?php

/**
 * @file
 * Contains fut_group.module.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Url;
use Drupal\group\Entity\Group;
use Drupal\group\Entity\GroupContent;
use Drupal\group\Entity\GroupContentType;
use Drupal\group_permissions\Entity\GroupPermission as GroupPermissionEntity;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\Entity\Term;
use Drupal\paragraphs\Entity\Paragraph;
use Drupal\Core\Form\FormState;

/**
 * Implements hook_help().
 */
function fut_group_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the fut_group module.
    case 'help.page.fut_group':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Futurium Group module contains group related configurations.') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_entity_type_build().
 */
function fut_group_entity_type_build(array &$entity_types) {
  // We set fut_navigation form view mode. So, we can load as a separate form
  // in the custom page.
  $view_modes = ['fut_navigation', 'fut_layout'];
  $group = $entity_types['group'];

  foreach ($view_modes as $view_mode) {
    $default_handler_class = $group->getHandlerClasses()['form']['add'];
    $group->setFormClass($view_mode, $default_handler_class);
  }
}

/**
 * Implements hook_theme().
 */
function fut_group_theme($existing, $type, $theme, $path) {
  return [
    'group_navigation' => [
      'variables' => [
        'links' => [],
        'class' => NULL,
      ],
    ],
  ];
}

/**
 * Implements hook_views_data_alter().
 */
function fut_group_views_data_alter(array &$data) {
  $data['groups_field_data']['accessible_groups'] = [
    'title' => t('Accessible Groups'),
    'filter' => [
      'title' => t('Accessible Groups'),
      'help' => t('Filter by group where current user is member.'),
      'field' => 'id',
      'id' => 'fut_group_accessible_groups',
    ],
  ];
}

/**
 * Implements hook_group_insert().
 */
function fut_group_group_insert(Group $group) {
  // Add default about navigation item.
  // @see #61
  $paragraph = Paragraph::create([
    'type' => 'fut_functional_navigation_link',
    'fut_predefined_link' => 'about',
  ]);
  $paragraph->save();

  $group->fut_navigation_menu = [
    [
      'target_id' => $paragraph->id(),
      'target_revision_id' => $paragraph->getRevisionId(),
    ],
  ];
  $group->save();
}

/**
 * Implements hook_field_widget_form_alter().
 */
function fut_group_field_widget_form_alter(
  &$element,
  FormStateInterface $form_state,
  $context
) {
  $field_definition = $context['items']->getFieldDefinition();

  if (!empty($field_definition) && $field_definition->getName() == 'fut_collection_item' && $field_definition->id() == 'paragraph.fut_functional_navigation_link.fut_collection_item') {
    $element['#options'] = _fut_group_get_group_options();
    $element['#states'] = [
      'invisible' => [
        'select[name="fut_navigation_menu[' . $context['form']['#parents'][1] . '][subform][fut_predefined_link]"]' => ['value' => 'about'],
      ],
    ];
  }

  if (!empty($field_definition) && $field_definition->getName() == 'fut_collection') {
    $element['#options'] = _fut_group_get_group_options();
  }

  // Alter entity reference field when creating a "subgroup" group_content.
  if (!empty($field_definition)
    && $element['#entity_type'] == 'group_content'
    && $field_definition->getName() == 'entity_id'
    && $field_definition->getType() == 'entity_reference'
  ) {
    if ($element['target_id']['#target_type'] == 'group') {
      // Use custom plugin to list groups without relationship to other groups.
      $element['target_id']['#selection_handler'] = 'fut_group:group_one_level';
    }
  }
}

/**
 * Gets group collection options.
 */
function _fut_group_get_group_options() {
  $options = [];
  $request_extractor = \Drupal::getContainer()->get('fut_group.request_entity_extractor');
  $group = $request_extractor->getGroup();
  if (!empty($group)) {
    // Load group from node.
    $node = $request_extractor->getNode();
    if ($node) {
      $group_content_items = GroupContent::loadByEntity($node);
      if (!empty($group_content_items)) {
        $group_content = reset($group_content_items);
        $group = $group_content->getGroup();
      }
    }
  }

  if (!empty($group)) {
    $group_roles = [];
    $custom_permissions = [];
    $group_permission = GroupPermissionEntity::loadByGroup($group);
    if ($group_permission) {
      $custom_permissions = $group_permission->getPermissions()
        ->first()
        ->getValue();
      if (!empty($custom_permissions)) {
        // Get roles of the current user.
        $group_roles = _fut_group_get_group_user_roles($group,
          \Drupal::currentUser());
      }
    }

    $query = \Drupal::entityQuery('taxonomy_term');
    $query->condition('vid', 'fut_collections');
    $query->condition('fut_related_group', $group->id());
    $collection_items = Term::loadMultiple($query->execute());

    $by_pass_access = \Drupal::currentUser()
        ->hasPermission('bypass group access') || \Drupal::currentUser()
        ->hasPermission('manage group collections');

    if ($collection_items) {
      $options['_none'] = t('- None -');
      foreach ($collection_items as $collection_item) {
        if (!$by_pass_access) {
          $is_allowed = FALSE;
          foreach ($group_roles as $role_name => $group_role) {
            if (in_array("view {$collection_item->id()} collection",
              $custom_permissions[$role_name])) {
              $is_allowed = TRUE;
            }
          }
        }
        else {
          $is_allowed = TRUE;
        }

        if ($is_allowed) {
          $options[$collection_item->id()] = $collection_item->getName();
        }
      }
    }
  }

  return $options;
}

/**
 * Get user roles in the group.
 *
 * @param Group $group
 *   Group.
 * @param AccountInterface $account
 *   User.
 */
function _fut_group_get_group_user_roles($group, $account) {
  $group_roles = [];
  $member = $group->getMember($account);

  if (!empty($member)) {
    $group_roles = $member->getRoles();
  }

  $group_roles[$group->getGroupType()->getAnonymousRoleId()] = '';
  $group_roles[$group->getGroupType()->getOutsiderRoleId()] = '';
  return $group_roles;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function fut_group_form_taxonomy_term_fut_collections_delete_form_alter(
  &$form,
  FormStateInterface $form_state,
  $form_id
) {
  $request_extractor = \Drupal::getContainer()->get('fut_group.request_entity_extractor');
  if ($group = $request_extractor->getGroup()) {
    $form['actions']['cancel']['#url'] = Url::fromRoute('fut_group.manage_group_content.collections', [
      'group' => $group->id(),
    ]);
  }

  // Redirect to collections page after creation.
  foreach (array_keys($form['actions']) as $action) {
    if ($action != 'preview' && isset($form['actions'][$action]['#type']) && $form['actions'][$action]['#type'] === 'submit') {
      $form['actions'][$action]['#submit'][] = '_fut_group_form_taxonomy_term_fut_collections_submit';
    }
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function fut_group_form_taxonomy_term_fut_collections_form_alter(
  &$form,
  FormStateInterface $form_state,
  $form_id
) {

  // Hide hierarchy field.
  $form['relations']['#access'] = FALSE;

  // Redirect to collections page after creation.
  foreach (array_keys($form['actions']) as $action) {
    if ($action != 'preview' && isset($form['actions'][$action]['#type']) && $form['actions'][$action]['#type'] === 'submit') {
      $form['actions'][$action]['#submit'][] = '_fut_group_form_taxonomy_term_fut_collections_submit';
    }
  }
}

/**
 *
 */
function _fut_group_form_taxonomy_term_fut_collections_submit(array $form, FormState $form_state) {
  $request_extractor = \Drupal::getContainer()->get('fut_group.request_entity_extractor');
  if ($group = $request_extractor->getGroup()) {
    $form_state->setRedirect('fut_group.manage_group_content.collections', [
      'group' => $group->id(),
    ]);
    return;
  }
}

/**
 * Implements hook_node_access().
 *
 * We add new logic for collection, everything else is the same as in
 * gnode_node_access.
 */
function fut_group_node_access(NodeInterface $node, $op, AccountInterface $account) {

  // We do not care about create access as we have our own wizard for that. Any
  // operation aside from 'view', 'update' and 'delete' is also unsupported.
  if (!in_array($op, ['view', 'update', 'delete'])) {
    return AccessResult::neutral();
  }

  // Some modules, including the code in \Drupal\node\NodeForm::access() may
  // check for 'view', 'update' or 'delete' access on new nodes, even though
  // that makes little sense. We need to account for it to avoid crashes because
  // we would otherwise query the DB with a non-existent node ID.
  if ($node->isNew()) {
    return AccessResult::neutral();
  }

  $plugin_id = 'group_node:' . $node->bundle();

  // Only act if there are group content types for this node type.
  $group_content_types = GroupContentType::loadByContentPluginId($plugin_id);
  if (empty($group_content_types)) {
    return AccessResult::neutral();
  }

  // Load all the group content for this node.
  $group_contents = \Drupal::entityTypeManager()
    ->getStorage('group_content')
    ->loadByProperties([
      'type' => array_keys($group_content_types),
      'entity_id' => $node->id(),
    ]);

  // If the node does not belong to any group, we have nothing to say.
  if (empty($group_contents)) {
    return AccessResult::neutral();
  }

  /** @var \Drupal\group\Entity\GroupInterface[] $groups */
  $groups = [];
  foreach ($group_contents as $group_content) {
    /** @var \Drupal\group\Entity\GroupContentInterface $group_content */
    $group = $group_content->getGroup();
    $groups[$group->id()] = $group;
  }

  $collection_id = NULL;
  if (!empty($node->fut_collection->target_id)) {
    $collection_id = $node->fut_collection->target_id;
  }

  $custom_permissions = _fut_group_check_custom_group_permissions($group);
  $has_collection_permissions = !empty($collection_id) && !empty($custom_permissions);

  // From this point on you need group to allow you to perform the operation.
  switch ($op) {
    case 'view':
      foreach ($groups as $group) {
        // Check collection first.
        if ($has_collection_permissions) {
          if (_fut_group_check_permissions_by_collection("$op $collection_id collection", $custom_permissions, $group, $account)) {
            return AccessResult::allowed();
          }
          else {
            return AccessResult::forbidden();
          }
        }
        else {
          if ($node->isPublished()) {
            if ($group->hasPermission("$op $plugin_id entity", $account)) {
              return AccessResult::allowed();
            }
            else {
              return AccessResult::forbidden();
            }
          }
          elseif ($group->hasPermission("$op unpublished $plugin_id entity",
            $account)) {
            return AccessResult::allowed();
          }
          else {
            return AccessResult::forbidden();
          }
        }
      }
      break;

    case 'update':
    case 'delete':
      // Check collection first.
      if ($has_collection_permissions) {
        if (_fut_group_check_permissions_by_collection("$op $collection_id collection", $custom_permissions, $group, $account)) {
          return AccessResult::allowed();
        }
        else {
          return AccessResult::forbidden();
        }
      }
      else {
        foreach ($groups as $group) {
          if ($group->hasPermission("$op any $plugin_id entity", $account)) {
            return AccessResult::allowed();
          }
          elseif ($account->id() == $node->getOwnerId() && $group->hasPermission("$op own $plugin_id entity",
              $account)) {
            return AccessResult::allowed();
          }
        }
      }
      break;
  }

  // Instead of outright forbidding access when no group granted it, we return
  // a neutral access result to play nice with other modules. If the end result
  // is still neutral, Drupal will deny access anyway unless the node grants
  // system allows the operation in a last ditch effort to determine access.
  return AccessResult::neutral();
}

function _fut_group_check_custom_group_permissions(Group $group) {
  $group_permission = GroupPermissionEntity::loadByGroup($group);
  $custom_permissions = [];
  if ($group_permission) {
    $custom_permissions = $group_permission->getPermissions()
      ->first()
      ->getValue();
  }

  return $custom_permissions;
}

    /**
 * Checks permissions for collection.
 *
 * @param string $permission
 *   Permission.
 * @param array $custom_permissions
 *   Custom permissions
 * @param \Drupal\group\Entity\Group $group
 *   Group.
 * @param \Drupal\Core\Session\AccountInterface $account
 *   Current user.
 *
 * @return bool
 *   Result of the check.
 */
function _fut_group_check_permissions_by_collection($permission, array $custom_permissions, Group $group, AccountInterface $account) {

  if (!empty($custom_permissions)) {
    // Get roles of the current user.
    $group_roles = _fut_group_get_group_user_roles($group, $account);

    foreach ($group_roles as $role_name => $group_role) {
      if (in_array($permission, $custom_permissions[$role_name])) {
        return TRUE;
      }
    }
  }

  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function fut_group_form_views_exposed_form_alter(&$form, FormStateInterface $form_state, $form_id) {

  // Hacky solution to filter posts per specific collection / any / none.
  if ($form['#id'] == 'views-exposed-form-fut-group-posts-management-default') {
    // Remove operator title.
    unset($form['fut_collection_target_id_op']['#title']);
    // Remove unnessessary options from operetor field.
    $form['fut_collection_target_id_op']['#options'] = array_intersect_key($form['fut_collection_target_id_op']['#options'], array_flip(['or', 'empty']));

    // Apply better wordign for operator.
    $form['fut_collection_target_id_op']['#options']['or'] = \Drupal::translation()->translate('has collection');
    $form['fut_collection_target_id_op']['#options']['empty'] = \Drupal::translation()->translate('no collection');

    // Show fut_collection_target_id only when correct operator is selected.
    $form['fut_collection_target_id']['#states'] = [
      'visible' => [
        ':input[name="fut_collection_target_id_op"]' => ['value' => 'or'],
      ],
    ];

    $form['fut_colletion_exposed_filter'] = [
      '#type' => 'fieldset',
      '#title' => \Drupal::translation()->translate('Collection'),
      'fut_collection_target_id_op' => $form['fut_collection_target_id_op'],
      'fut_collection_target_id' => $form['fut_collection_target_id'],
    ];
    // Remove original form elements.
    unset($form['fut_collection_target_id_op']);
    unset($form['fut_collection_target_id']);
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function fut_group_menu_local_tasks_alter(&$data, $route_name) {
  unset($data['tabs'][1]['fut_group.manage_group_content.add_collection']);
  unset($data['tabs'][1]['fut_group.manage_group_content.delete_collection']);
  unset($data['tabs'][1]['fut_group.manage_group_content.edit_collection']);
  unset($data['tabs'][0]['group_permissions.link.group_permissions']);
  unset($data['tabs'][0]['group.edit_form']);
  unset($data['tabs'][0]['group.delete_form']);
  unset($data['tabs'][0]['fut_group.manage_group_content']);
  unset($data['tabs'][0]['group.content']);
}

/**
 * Implements hook_ENTITY_TYPE_access().
 */
function fut_group_comment_access(EntityInterface $entity, $operation, AccountInterface $account){

  // We do not care about create / view. (these ones are system wide).
  if (!in_array($operation, ['update', 'delete'])) {
    return AccessResult::neutral();
  }

  $referenced_entities = $entity->referencedEntities();

  foreach ($referenced_entities as $referenced_entity) {
    if ($referenced_entity instanceof NodeInterface) {
      $parent_node = $referenced_entity;
      break;
    }
  }

  $entity_type_manager = \Drupal::entityTypeManager();

  $group_content = $entity_type_manager
    ->getStorage('group_content')
    ->loadByEntity($parent_node);
  $group_content = reset($group_content);

  if (empty($group_content)) {
    return AccessResult::neutral();
  }

  // We need the group to check if account has permission.
  $group = $group_content->getGroup();

  switch ($operation) {
    case 'update':
    case 'delete':
      if ($group->hasPermission("administer group comments", $account)) {
        return AccessResult::allowed();
      }
      break;

    default:
      return AccessResult::neutral();
      break;
  }

}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function fut_group_form_alter(&$form, FormStateInterface $form_state, $form_id){
  switch ($form_id) {
    case 'group_content_fut_open-group_membership_group-leave_form':
      // Change the cancel link url to group page instead of membership.
      $group = $form_state->getFormObject()->getEntity()->getGroup();
      $form['actions']['cancel']['#url'] = Url::fromRoute('entity.group.canonical', [
        'group' => $group->id(),
      ]);
      break;
  }
}

/**
 * Implements hook_entity_create_access().
 *
 * @see \Drupal\workspaces\EntityAccess
 */
function fut_group_entity_create_access(AccountInterface $account, array $context, $entity_bundle) {
  $extractor = \Drupal::getContainer()->get('fut_group.request_entity_extractor');
  if ($extractor->getRouteMatch()->getRouteName() == 'entity.group_content.create_form' && isset($context['entity_type_id']) && $context['entity_type_id'] == 'media') {
    $plugin_id = $extractor->getRouteMatch()->getParameter('plugin_id');
    $group = $extractor->getGroup();
    if (!empty($group) && !empty($plugin_id)) {
      if ($group->hasPermission("create $plugin_id entity", $account)) {
        return AccessResult::allowed();
      }
    }
  }

  return AccessResult::neutral();
}
